--- a/drivers/net/wireless/ath/ath10k/sdio.c
+++ b/drivers/net/wireless/ath/ath10k/sdio.c
@@ -31,6 +30,16 @@ void ath10k_sdio_fw_crashed_dump(struct ath10k *ar);
 #define ATH10K_SDIO_VSG_BUF_SIZE	(64 * 1024)
 
 /* inlined helper functions */
+#ifdef CONFIG_MMC_SDHCI_TEGRA
+static void ath10k_clock_gating_control(struct sdio_func *func, bool enable)
+{
+	struct mmc_host *host = func->card->host;
+
+	pr_err("ath10k: Host Clock Gating value %d\n", enable);
+	if (host->ops->voltage_switch_req)
+		host->ops->voltage_switch_req(host, enable);
+}
+#endif /* CONFIG_MMC_SDHCI_TEGRA */
 
 static inline int ath10k_sdio_calc_txrx_padded_len(struct ath10k_sdio *ar_sdio,
 						   size_t len)
@@ -562,7 +571,7 @@ static int ath10k_sdio_mbox_rx_alloc(struct ath10k *ar,
 				    ATH10K_HTC_MBOX_MAX_PAYLOAD_LENGTH);
 			ret = -ENOMEM;
 
-			ath10k_core_start_recovery(ar);
+			queue_work(ar->workqueue, &ar->restart_work);
 			ath10k_warn(ar, "exceeds length, start recovery\n");
 
 			goto err;
@@ -961,7 +970,7 @@ static int ath10k_sdio_mbox_read_int_status(struct ath10k *ar,
 	ret = ath10k_sdio_read(ar, MBOX_HOST_INT_STATUS_ADDRESS,
 			       irq_proc_reg, sizeof(*irq_proc_reg));
 	if (ret) {
-		ath10k_core_start_recovery(ar);
+		queue_work(ar->workqueue, &ar->restart_work);
 		ath10k_warn(ar, "read int status fail, start recovery\n");
 		goto out;
 	}
@@ -1058,7 +1067,7 @@ static int ath10k_sdio_mbox_proc_pending_irqs(struct ath10k *ar,
 
 out:
 	/* An optimization to bypass reading the IRQ status registers
-	 * unnecessarily which can re-wake the target, if upper layers
+	 * unecessarily which can re-wake the target, if upper layers
 	 * determine that we are in a low-throughput mode, we can rely on
 	 * taking another interrupt rather than re-checking the status
 	 * registers which can re-wake the target.
@@ -1249,7 +1258,7 @@ static int ath10k_sdio_bmi_exchange_msg(struct ath10k *ar,
 	 *        Wait for first 4 bytes to be in FIFO
 	 *        If CONSERVATIVE_BMI_READ is enabled, also wait for
 	 *        a BMI command credit, which indicates that the ENTIRE
-	 *        response is available in the FIFO
+	 *        response is available in the the FIFO
 	 *
 	 *  CASE 3: length > 128
 	 *        Wait for the first 4 bytes to be in FIFO
@@ -1364,11 +1373,8 @@ static void ath10k_rx_indication_async_work(struct work_struct *work)
 		ep->ep_ops.ep_rx_complete(ar, skb);
 	}
 
-	if (test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags)) {
-		local_bh_disable();
+	if (test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
 		napi_schedule(&ar->napi);
-		local_bh_enable();
-	}
 }
 
 static int ath10k_sdio_read_rtc_state(struct ath10k_sdio *ar_sdio, unsigned char *state)
@@ -1586,6 +1592,11 @@ static int ath10k_sdio_hif_power_up(struct ath10k *ar,
 		return ret;
 	}
 
+#ifdef CONFIG_MMC_SDHCI_TEGRA
+	/* Disable clock gating of Host Controller */
+	ath10k_clock_gating_control(func, false);
+#endif /* CONFIG_MMC_SDHCI_TEGRA */
+
 	sdio_claim_host(func);
 
 	ret = sdio_enable_func(func);
@@ -1634,7 +1645,12 @@ static void ath10k_sdio_hif_power_down(struct ath10k *ar)
 		return;
 	}
 
-	ret = mmc_hw_reset(ar_sdio->func->card);
+#ifdef CONFIG_MMC_SDHCI_TEGRA
+	/* Re-enable clock gating of Host Controller */
+	ath10k_clock_gating_control(ar_sdio->func, true);
+#endif /* CONFIG_MMC_SDHCI_TEGRA */
+
+	ret = mmc_hw_reset(ar_sdio->func->card);
 	if (ret)
 		ath10k_warn(ar, "unable to reset sdio: %d\n", ret);
 
@@ -1863,7 +1879,7 @@ static int ath10k_sdio_hif_start(struct ath10k *ar)
 	struct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);
 	int ret;
 
-	ath10k_core_napi_enable(ar);
+	napi_enable(&ar->napi);
 
 	/* Sleep 20 ms before HIF interrupts are disabled.
 	 * This will give target plenty of time to process the BMI done
@@ -1966,15 +1982,9 @@ static void ath10k_sdio_hif_stop(struct ath10k *ar)
 {
 	struct ath10k_sdio_bus_request *req, *tmp_req;
 	struct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);
-	struct sk_buff *skb;
 
 	ath10k_sdio_irq_disable(ar);
 
-	cancel_work_sync(&ar_sdio->async_work_rx);
-
-	while ((skb = skb_dequeue(&ar_sdio->rx_head)))
-		dev_kfree_skb_any(skb);
-
 	cancel_work_sync(&ar_sdio->wr_async_work);
 
 	spin_lock_bh(&ar_sdio->wr_async_lock);
@@ -1996,7 +2006,8 @@ static void ath10k_sdio_hif_stop(struct ath10k *ar)
 
 	spin_unlock_bh(&ar_sdio->wr_async_lock);
 
-	ath10k_core_napi_sync_disable(ar);
+	napi_synchronize(&ar->napi);
+	napi_disable(&ar->napi);
 }
 
 #ifdef CONFIG_PM
@@ -2240,7 +2251,7 @@ static bool ath10k_sdio_is_fast_dump_supported(struct ath10k *ar)
 
 	ath10k_dbg(ar, ATH10K_DBG_SDIO, "sdio hi_option_flag2 %x\n", param);
 
-	return !!(param & HI_OPTION_SDIO_CRASH_DUMP_ENHANCEMENT_FW);
+	return param & HI_OPTION_SDIO_CRASH_DUMP_ENHANCEMENT_FW;
 }
 
 static void ath10k_sdio_dump_registers(struct ath10k *ar,
@@ -2316,8 +2327,8 @@ static int ath10k_sdio_dump_memory_section(struct ath10k *ar,
 	}
 
 	count = 0;
-	i = 0;
-	for (; cur_section; cur_section = next_section) {
+
+	for (i = 0; cur_section; i++) {
 		section_size = cur_section->end - cur_section->start;
 
 		if (section_size <= 0) {
@@ -2327,7 +2338,7 @@ static int ath10k_sdio_dump_memory_section(struct ath10k *ar,
 			break;
 		}
 
-		if (++i == mem_region->section_table.size) {
+		if ((i + 1) == mem_region->section_table.size) {
 			/* last section */
 			next_section = NULL;
 			skip_size = 0;
@@ -2370,6 +2381,12 @@ static int ath10k_sdio_dump_memory_section(struct ath10k *ar,
 		}
 
 		count += skip_size;
+
+		if (!next_section)
+			/* this was the last section */
+			break;
+
+		cur_section = next_section;
 	}
 
 	return count;
@@ -2390,7 +2407,7 @@ static int ath10k_sdio_dump_memory_generic(struct ath10k *ar,
 						      buf,
 						      current_region->len);
 
-	/* No individual memory sections defined so we can
+	/* No individiual memory sections defined so we can
 	 * copy the entire memory region.
 	 */
 	if (fast_dump)
@@ -2504,7 +2521,7 @@ void ath10k_sdio_fw_crashed_dump(struct ath10k *ar)
 
 	ath10k_sdio_enable_intrs(ar);
 
-	ath10k_core_start_recovery(ar);
+	queue_work(ar->workqueue, &ar->restart_work);
 }
 
 static int ath10k_sdio_probe(struct sdio_func *func,
@@ -2648,9 +2666,10 @@ static void ath10k_sdio_remove(struct sdio_func *func)
 
 	netif_napi_del(&ar->napi);
 
-	destroy_workqueue(ar_sdio->workqueue);
-
 	ath10k_core_destroy(ar);
+
+	flush_workqueue(ar_sdio->workqueue);
+	destroy_workqueue(ar_sdio->workqueue);
 }
 
 static const struct sdio_device_id ath10k_sdio_devices[] = {
@@ -2667,10 +2686,29 @@ static struct sdio_driver ath10k_sdio_driver = {
 	.probe = ath10k_sdio_probe,
 	.remove = ath10k_sdio_remove,
 	.drv = {
+		.owner = THIS_MODULE,
 		.pm = ATH10K_SDIO_PM_OPS,
 	},
 };
-module_sdio_driver(ath10k_sdio_driver);
+
+static int __init ath10k_sdio_init(void)
+{
+	int ret;
+
+	ret = sdio_register_driver(&ath10k_sdio_driver);
+	if (ret)
+		pr_err("sdio driver registration failed: %d\n", ret);
+
+	return ret;
+}
+
+static void __exit ath10k_sdio_exit(void)
+{
+	sdio_unregister_driver(&ath10k_sdio_driver);
+}
+
+module_init(ath10k_sdio_init);
+module_exit(ath10k_sdio_exit);
 
 MODULE_AUTHOR("Qualcomm Atheros");
 MODULE_DESCRIPTION("Driver support for Qualcomm Atheros 802.11ac WLAN SDIO devices");
